---
description: 学习图论中用于求最短路径的两种算法，了解有关算法的时间复杂度的知识
---

# Lesson 33

## 一、图论（二）

### 1.1 Floyd 算法

Floyd 算法是一种用于求所有点到所有点最短路径的算法。

#### 1.1.1 原理

对于一个带权图，两点之间的最短距离并不一定就是由此及彼的权值。就像对于下面这个图：

![带权图例](https://s2.loli.net/2022/07/31/lIyiNOcYqr7UaFg.png)

从 1 到 3 的最短距离并不是直接从 1 到 3 的权值 6，而是从 1 到 2 再到 3 所用的距离 5。使用 Floyd 算法求出最小值的原理就是，先拿出一条边的起点 $$V_i$$ 与终点 $$V_j$$，再拿出一个非起非终的点 $$V_k$$，然后判断：从 $$V_i$$ 直接到 $$V_j$$ ，以及从 $$V_i$$ 经 $$V_k$$ 再到 $$V_j$$，这两种方案中，哪一种方案的距离最小。将这个最小的距离保存起来，并在之后的遍历中与之后经另一个过渡点算出的距离相比取最小值，就可以保证取到从 $$V_i$$ 到 $$V_j$$ 所需要的最小距离。

当然，写程序时还是有需要注意的地方。假设 $$V_a$$ 与 $$V_b$$ 之间没有边连接（或者没有正确方向的边连接），输入数据时不会体现，就会默认权值为 0。这样在计算时就会影响到取最小值。我们可以给所有边的权值先赋值为无穷大（程序中用一个很大的数来代替），将自己到自己的权值赋值为 0，再将输入的值赋给各条边，就基本可以保证取到最小值。

#### 1.1.2 应用

给出一个有向图中顶点的数量、边的数量、每条边的起点终点及权值，请求出图中所有点到所有点的所需要的最短距离（距离等于所过边的权值之和）。

```cpp
# include <iostream>
# include <cstring>
# include <cstdio>
using namespace std;

/************
 v为顶点数量
 e为边的数量
 g为图的邻接数组
*************/
int v, e, g[105][105];

int main () {
    
    cin >> v >> e;
    memset(g, 0x3f, sizeof(g)); // 将所有边初始化为无穷大
    for (int i = 1; i <= v; i++)
        g[i][i] = 0; // 将数组主对角线上的元素赋值为0
    
    for (int i = 1; i <= e; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        g[a][b] = c; // 将各条边的权值写进邻接数组
    }
    
    for (int i = 1; i <= v; i++) // 遍历所有过渡点
        for (int j = 1; j <= v; j++) // 遍历行
            for (int k = 1; k <= v; k++) // 遍历列
                // 当前数组元素等于原距离与经由过渡点距离之和之间的最小值
                g[j][k] = min(g[j][k], g[j][i]+g[i][k]);
    
    for (int i = 1; i <= v; i++) {
        for (int j = 1; j <= v; j++)
            // 左对齐输出
            printf("%-3d", g[i][j]);
        cout << endl;   
    }

    return 0;
}
```

### 1.2 Dijkstra 算法

Floyd 算法的时间复杂度为 $$O(n^3)$$，所以它能够处理的数据量非常有限。这里引入一个新的算法，称为 Dijkstra 算法（Dijkstra /ˈdaɪkstrə/）。这是一种用来计算单个点到所有点最短路径的算法。

#### 1.2.1 原理

Dijkstra 算法的思想是基于贪心策略建立的。从起始顶点开始，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。

具体地说，我们可以引进两个集合 S 和 U，S 用来表示**已求出最短路径的顶点**以及**相应的最短路径长度**，U 用来记录**还没有求出最短路径的顶点**以及**该顶点到起点的距离**。我们先把起点初始化到 S 中，这时 U 中为非起点的所有顶点，我们称 U 中**起点到各顶点的距离**为该顶点的**路径**。接着我们从 U 中找出路径最短的顶点，加入到 S 中。然后，更新 U 中的顶点与顶点对应的路径。接下来我们不断重复**找最小路径**和**更新顶点与路径**这两个操作，直到遍历完所有的顶点。

#### 1.2.2 应用

给出一个有向图中顶点的数量、边的数量、每条边的起点终点及权值，请求出图中编号为 1 的顶点到所有点的所需要的最短距离（距离等于所过边的权值之和）。

```cpp
# include <iostream>
# include <cstring>
# include <climits>
using namespace std;

/*******************************************
 v为顶点数量
 e为边的数量
 g为图的邻接数组
 dis为图中各个顶点的路径("路径"满足1.2.1节中的定义)
 t为临时变量，用于存储最短路径的顶点
 mina为用于打擂台求最短路径长度的变量
********************************************/
int v, e, g[105][105], dis[105], t, mina;
// book数组用于标记顶点是否遍历过
bool book[105];

int main () {
    
    cin >> v >> e;
    
    // 将所有边全部初始化为无穷大
    memset(g, 0x3f, sizeof(g));
    // 将所有点的路径全部初始化为无穷大
    memset(dis, 0x3f, sizeof(dis));
    
    // 初始化数组主对角线上的元素为0
    for (int i = 1; i <= v; i++)
        g[i][i] = 0;
    
    // 将各条边的权值写进邻接数组
    for (int i = 1; i <= e; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        g[a][b] = c;
    }
    
    // 将每个顶点的路径都初始化为1到这个顶点的直接距离
    for (int i = 1; i <= v; i++)
        dis[i] = g[1][i];
    
    book[1] = 1; // 初始化起点为已遍历过
    
    // 遍历其他顶点
    for (int i = 1; i <= v-1; i++) {
        mina = INT_MAX; // 定义最小值变量
        // 打擂台
        for (int j = 1; j <= v; j++) {
            // 如果没有遍历过且该顶点的路径小于当前最小值
            if (!book[j] && dis[j] < mina) {
                // 更新最短路径
                mina = dis[j];
                // 保存顶点编号
                t = j;
            }
        }
        // 将这个编号的顶点标记为已遍历过
        book[t] = 1;
        // 基于最小值扩展
        for (int j = 1; j <= v; j++) {
            // 如果(这个顶点的路径)大于(最短路径)与(从最短路径顶点到这个顶点的距离)之和
            if (dis[j] > dis[t] + g[t][j])
                // 更新当前顶点的路径
                dis[j] = dis[t] + g[t][j];
        }
    }
    
    // 输出各个顶点的路径
    for (int i = 1; i <= v; i++)
        cout << dis[i] << " "; 
    
    return 0;
}
```

## 二、时间复杂度

时间复杂度是算法的一种性质，通常用来表示算法运行时在耗时层面上的效率。一般来说，时间复杂度越小的算法需要的运行时间越少。

要估算一个算法的时间复杂度，可以看这个算法内部需要嵌套多少层循环，嵌套一层循环（最外层也算）就在总复杂度上乘以一个 n（n 表示数据范围）。如果当前层循环只需要循环到所给数据范围的算术平方根，那么这层循环的时间复杂度就为 $$O(\log n)$$ 即 $$O(\sqrt{n})$$。如果算法内存在互相并列的循环，只需要看哪一个循环的时间复杂度最大即可，因为其他的小循环充其量也只是在系数级别上增加运行时间，对总运行时间的影响相对不会太大。

大多数算法题都会对程序运行时间作出限制，通常为一秒。下面是一些不同时间复杂度算法在一秒内能够运行出结果所支持的数据范围。

* 对于 $$O(\log n)$$ 即 $$O(\sqrt{n})$$ 的算法，若想令其在一秒内得出结果，其所支持的数据量基本不大于 `long long` 类型所能容纳的范围（大约为 $$9.2 \times 10^{18}$$）；
* 对于 $$O(n)$$ 的算法，若想令其在一秒内得出结果，其所支持的数据量基本不大于 $$10^7$$；
* 对于 $$O(n\log n)$$ 即 $$O(n\sqrt{n})$$ 的算法，若想令其在一秒内得出结果，其所支持的数据量通常在 $$10^5$$ 至 $$5\times10^5$$ 范围内。
* 对于 $$O(n^2)$$ 的算法，若想令其在一秒内得出结果，其所支持的数据量通常在 1,000 至 5,000 范围内；
* 对于 $$O(n^3)$$ 的算法，若想令其在一秒内得出结果，其所支持的数据量通常在 200 至 500 范围内；
* 对于 $$O(2^n)$$ 的算法，若想令其在一秒内得出结果，其所支持的数据量通常在 20 至 24 范围内；
* 对于 $$O(n!)$$ 的算法，若想令其在一秒内得出结果，其所支持的数据量基本不大于 12。
