---
description: 进一步分析并学习桶排序、冒泡排序、选择排序、插入排序等排序算法
---

# Lesson 18

{% hint style="info" %}
请注意，在本页面所显示的代码段中，可能出现行内缩进过多或过少等现象，这是不同笔记软件和集成开发环境所预设的制表符长度不同所导致的，属正常现象。
{% endhint %}

## 一、排序（二）

### 1.1 桶排序

桶排序的排序方法（升序）是，开一个与数据大小范围相当的数组，每输入一个数据，就在这个数据所对应的下标代表的数字上加 1。输出时，只用输出那些范围内非 0 的元素就可以了，也利于视情况去重。

```cpp
#include <bits/stdc++.h>
using namespace std;

int a[1005], n, t;

int main() {
	
	cin >> n;
	
	while(n--) {
		cin >> t;
		a[t]++;
	}
	
    // 使用桶排序去重
	for (int i = 1; i <= 1000; i++)
		if (a[i]) cout << i << " ";
	
	cout << endl;
	
    // 不去重
	for (int i = 1; i <= 1000; i++)
		while(a[i]--)
			cout << i << " ";

	return 0;
}
```

尽管从代码量角度讲，使用 `sort()` 函数排序需要写的代码有时少于桶排序的代码量，但是桶排序的速度通常较快，具有较低的时间复杂度，尤其是在需要去重的时候。设数据规模为 n，则 `sort()` 函数的时间复杂度为 $$O(n\log n)$$，使用桶排序的时间复杂度最低能达到 $$O(n)$$，即使需要桶排序的数据全都是一样的，使用桶排序的时间复杂度也不会超过 $$O(n\log n)$$。

### 1.2 冒泡排序

冒泡排序的排序方法（升序）是，每次对所有数据中相邻的两个数进行比较，如果前一个比后面大，则将两者交换位置，再向后移一位开始比较；每一轮循环完，就一定能确定一个范围内的最大值。所以，如果设数据总数为 n，当前循环轮数为 i。一共只需要进行 $$n-1$$ 轮循环，而每轮循环内部需要比较 $$n-i$$ 次。

#### 1.2.1 传统冒泡排序

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, a[105];

int main() {
	
	cin >> n;
	
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	
	for (int i = 1; i <= n; i++) // 循环的轮数
		for (int j = 1; j <= n-i; j++) // 循环每一个数据
			if (a[j] > a[j+1]) swap(a[j], a[j+1]); // 交换不按顺序的数据

			
	for (int i = 1; i <= n; i++)
		cout << a[i] << " ";
	
	return 0;
}
```

冒泡排序的时间复杂度为 $$O(n^{2})$$，空间复杂度为 $$O(n)$$。虽然耗时较长，但是处理大量数据时在空间占用上优于桶排序。

#### 1.2.2 减少循环次数

为了解决耗时问题，也可以对某一些判定方式进行优化。有可能经历一定量的循环之后，虽然没有循环完，但是所有数据已经按照顺序排列了，这时我们再进行循环就是徒增烦恼和耗时。所以，可以定义一个变量用来标记在这次循环中所有数据是不是按顺序排列的，如果循环完一次之后发现这次循环中所有数据都是按顺序排列的，之后的循环就可以不用运行了。通过这种方法，可以在常数级别上削减程序运行耗时。

```cpp
//...

	for (int i = 1; i <= n; i++) {
		bool flag = 1; // 标记变量
		for (int j = 1; j <= n-i; j++)
			if (a[j] > a[j+1]) swap(a[j], a[j+1]), flag = 0; // 数据并非按顺序排列
		if (flag) break; // 如果是按顺序排列则跳出循环
	}

//...
```

### 1.3 选择排序

选择排序的排序方法（升序）是，在每轮循环中寻找范围内的最小值，交换到已排序数字的末尾，每轮循环结束后从当前已排序数据量的后一位重新开始查找。也就是说，从第一位开始，查找这一位到最后一位之间的最小值，就能确保全部循环结束后的数据按顺序排列。这样，若把数据量设为 n，当前循环轮数（数量上也等于已排序数据量大小减 1）为 i，则一共需要进行 $$n-1$$ 轮循环，每轮循环查找的次数为 $$n-i+1$$。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, a[105], pos, mina;

int main() {
	
	cin >> n;
	
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	
	for (int i = 1; i < n; i++) {
		mina = INT_MAX, pos = 0; // 分别赋最小值变量和位置记录变量
		for (int j = i; j <= n; j++)
			if (a[j] < mina) mina = a[j], pos = j; // 不断寻找最小值
		swap(a[i], a[pos]); // 一轮循环完毕后将已找到的最小值交换至已排序数据的末位
	}
	
	for (int i = 1; i <= n; i++)
		cout << a[i] << " ";
	
	return 0;
}
```

选择排序的时间复杂度为 $$O(n^{2})$$，空间复杂度为 $$O(n)$$。

### 1.4 插入排序

插入排序的排序方法（升序）是，先取出第二个数据，与前一个数据作比较，如果前一个数据大于被取出的数据，则让前一个数据向后移一位，让被取出的数据向前移一位到前一个数据原来的位置；如果前一个数据小于或等于当前数据，则结束这一轮比较，将被取出的数据插入当前位置。若把数据量设为 n，当前循环轮数为 i，则需要进行 n 轮循环，每轮循环比较 i 次。

```cpp
#include <bits/stdc++.h>
using namespace std;

int a[105], n;

int main() {
	
	cin >> n;
	
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	
	for (int i = 1; i <= n; i++) {
		int ext = a[i], pos; // 声明需要取出的数据和位置记录变量
		for (int j = i-1; j >= 0; j--) { // 从被取出数据的前一位开始向前比较
			if (a[j] > ext) { // 如果比较的数字大于被取出的数据
				a[j+1] = a[j]; // 将这一数字向后移一位
				pos = j; // 记录此时被取出数据的位置
			}
			else // 如果小于
				break; // 跳出循环
		a[pos] = ext; // 将被取出数据插入回数组中
		}
	}

	for (int i = 1; i <= n; i++)
		cout << a[i] << " ";

	return 0;
}
```

插入排序的时间复杂度为 $$O(n^{2})$$，空间复杂度为 $$O(n)$$。
