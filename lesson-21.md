---
description: 学习高精度减法与乘法运算，初步认识数据结构，初步了解线性表中栈的逻辑原理
---

# Lesson 21

## 一、高精度（二）

### 1.1 高精度大小比较

对高精度数字进行大小比较时，第一步肯定是先比较数字的位数：数字位数大的肯定是较大的那个数。如果数位相同，再向后逐位比较大小，一旦发现有不同的情况，则输出结果。如果这两道工序都完成之后还是没有比较出大小，就代表这两个数相等，返回 `true` 即可（这是为了方便减法运算）。

核心代码如下：

```cpp
bool cmp(vector<int> M, vector <int> N) {
    if (M.size() != N.size()) return M.size() > N.size();
    for (int i = M.size(); i >= 0; i++) 
        if (M[i] != N[i]) return M[i] > N[i];
    return 1;
}
```

### 1.2 高精度减法

高精度减法的运算基于高精度大小比较，因为需要根据比较的大小来设置被减数和减数。单独处理计算为负数的情况只会使程序更为复杂，但是如果把商为负数的被减数和减数调换位置，这样所得的商就会是整数，输出时再输出一个负号即可。

高精度减法的另一个逻辑难点在于借位的处理。这就需要被减数**减去借位**再减去减数。如果这一位数字计算出的结果为负数，代表要向更高一位借位，就要把借位量设置为 1；如果这一位计算为正数，则不用借位，把借位量设置为 0。

但是按照这样的思路完成程序之后还会有问题。如果计算结果的数位个数小于被减数或者减数的数位，会在输出时添加不必要的前导 0（比如计算 $$999 - 990$$ 时会输出 009）。为了去掉前导 0，我们可以从最高位开始判断，只要**结果剩下的数位大于 1 位**且**最高的数位为 0**，就可以把这一位删掉。因此程序一旦检测到最高的数位不为 0，或者剩下的数位不到 1 位，就会跳出循环。

核心代码如下：

```cpp
// ...

vector<int> sub(vector<int> M, vector<int> N) {
    if (!(cmp(M, N))) return sub(N, M); // cmp()函数为1.1节中的大小比较函数
    int t = 0;
    vector<int> R;
    for (int i = 0; i < M.size(); i++) {
        t = M[i] - t;
        if (i < N.size()) t -= N[i];
        R.push_back((t+10)%10);
        if (t < 0) t = 1;
        else t = 0;
    }
    while (R.size() > 1 && R.back() == 0) R.pop_back();
    return R;
}

int main() {
    // ...
    if (!cmp(A, B)) cout << "-";
    vector<int> C = sub(A, B);
    // ...
}
```

测试数据

```
// 输入1
3731257821544352495282731761761454996564
7446693290462565594405727623865636956775

// 输出1
-3715435468918213099122995862104181960211

// 输入2
1000000000000000000000000000000
1234567890987654321234567890

// 输出2
998765432109012345678765432110
```

### 1.3 高精度乘法

#### 1.3.1 高精度数乘低精度数

想要实现高精度乘法，不妨先从高精度数乘低精度数开始着手。高精度乘法的思路是这样的：用高精度数的每一位与低精度数相乘，将乘积的各位存储到结果中，只要有进位就继续这样的操作，直至不在存在进位且循环到了最后一位。

```cpp
// ...

string a; int b;
vector<int> A;

vector<int> mul(vector<int> M, int N) {
    int t = 0;
    vector<int> R;
    for (int i = 0; i < M.size() || t; i++) {
        if (i < M.size()) t += M[i]*N;
        R.push_back(t%10);
        t /= 10;
    }
    return R;
}

int main() {
    // ...
    vector<int> C = mul(A, b);
    for (int i = C.size() - 1; i >= 0; i--) cout << C[i];
    return 0;
}
```

测试数据

```
// 输入
9876546576765757892385452709750175
138

// 输出
1362963427593674589149192473945524150
```

#### 1.3.2 高精度数乘高精度数

请回想计算竖式乘法时的思路：两个因数的每一位与另一个因数的每一位相乘，最终相加得出结果。可以看以下过程：

![4399×123](<.gitbook/assets/image (5).png>)

观察乘积各位数与两个因数的各位数之间的关系，可以发现，两个因数各数位的下标相加就是给商的那一个数位提供了一个加数。举例而言，因数 4399 中下标为 2 的数位上的数 **3** 和因数 123 中下标为 2 的数位上的数 **1** 合在一起，为计算商中下标为 4 的数位上的数 **4** 做出了贡献。而看到这几个数的下标：两个因数数字的下标均为 2，商数字的下标为 4，正好满足 $$2+2=4$$。还可以发现，因数和商中其他数位的下标也符合这种规律。

由此可以推导：若设第一个因数的数字下标为 i，第二个因数的数字下标为 j，则这两个数字计算出的乘积会作为商中下标为 $$i+j$$ 的数字的一个加数。

{% hint style="warning" %}
注意，计算乘法时也会出现前导 0 的情况。具体删除方法与减法中相同。
{% endhint %}

这样就可以写出代码：

```cpp
// ...

vector<int> mul(vector<int> M, vector<int> N) {
    vector<int> R(M.size() + N.size(), 0);
    for (int i = 0; i < M.size(); i++)
        for (int j = 0; j < N.size(); j++)
            R[i+j] += M[i]*N[j];
    int t = 0;
    for (int i = 0; i < R.size(); i++) {
        t += R[i];
        R[i] = t%10;
        t /= 10;
    }
    while (R.size() > 1 && R.back() == 0) R.pop_back();
    return R;
}

int main() {
    cin >> a >> b;
    for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');
    for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0');
    vector<int> C = mul(A, B);
    for (int i = C.size() - 1; i >= 0; i--) cout << C[i];
    return 0;
}
```

## 二、线性表

线性表是最简单、最基本的一类数据结构。

### 2.1 栈

**栈**（stack）是一种**后进先出**的线性表，可以把它简单理解为一个容器。也就是说，后放进容器里的东西必须要先拿出容器。同样的道理，后入栈的元素必须要先出栈。

**练习**

下面做一个练习来理解栈后进先出的特点。

我们一般生活中看到的数学表达式，形式上称为**中缀表达式**（infix notation）。但是这种表达式并不利于计算机理解表达式的运行优先级。与前缀或后缀记法不同的是，中缀记法中括号是必需的。计算过程中必须用括号将操作符和对应的操作数括起来，用于指示运算的次序。

下面是几个中缀表达式的例子：

$$
1+1 \\ 2\ast 3 \\ (3+8) / 5 \\ (9-6)/ 2\ast(4+7)
$$

对于计算机来说，**后缀表达式**（postfix notation）和**前缀表达式**（prefix notation）相比于中缀表达式更好理解。这里来学习如何将一个中缀表达式转换为后缀表达式，过程需要用到栈。请参考以下规则：

1. 如果遇到操作数，直接输出；
2. 如果取出的字符是运算符，则将该运算符与栈顶元素（当前栈中最后进入的元素）比较，如果该运算符优先级高于栈顶运算符的优先级，则将该运算符存入栈中，否则，将栈顶运算符输出，直至栈顶运算符的优先级低于该运算符优先级时停止继续输出运算符，最后将该运算符存入栈中。
3. 如果遇到左括号，则将其直接存入栈中；
4. 如果遇到右括号，则依次（从栈顶向栈底顺序）输出右括号和**距离栈顶最近的**左括号之间的所有栈元素（括号本身不用输出，直接抛弃出栈）。
5. 如果到达结尾，则依次（从栈顶向栈底顺序）输出所有还在栈中的栈元素。

接下来请思考如何把上面的四个中缀表达式转换为后缀表达式。

* 对于表达式 $$1+1$$：
  * 先输出一个操作数 1；
  * 发现运算符 + 后，因为栈中尚无元素，则直接存入栈中；
  * 再输出操作数 1；
  * 由于到达表达式末尾，则依次输出栈元素，此时输出 +。
* 对于表达式 $$2 \ast 3$$：
  * 先输出一个操作数 2；
  * 发现运算符 \* 后，因为栈中尚无元素，则直接存入栈中；
  * 再输出操作数 3；
  * 由于到达表达式末尾，则依次输出栈元素，此时输出 \*。
* 对于表达式 $$(3+8) / 5$$：
  * 发现左括号，直接存入栈中；
  * 输出操作数 3；
  * 发现运算符 + 后，因为其优先级高于左括号，则直接存入栈中；
  * 输出操作数 8；
  * 发现右括号，依次输出当前栈内的元素 +；
  * 发现运算符 / 后，因为栈中尚无元素，则直接存入栈中；
  * 输出操作数 5；
  * 由于到达表达式末尾，则依次输出栈元素，此时输出 /。
* 对于表达式 $$(9-6)/ 2\ast(4+7)$$：
  * 发现左括号，直接存入栈中；
  * 输出操作数 9；
  * 发现运算符 - 后，因为其优先级高于左括号，则直接存入栈中；
  * 输出操作数 6；
  * 发现右括号，依次输出当前栈内的元素 -；
  * 发现运算符 / 后，因为栈中尚无元素，则直接存入栈中；
  * 输出操作数 2；
  * 发现运算符 \*，由于 \* 的优先级不高于栈顶元素 / 的优先级，则依次输出当前栈内的元素 / 并将 \* 存入栈中；
  * 发现左括号，直接存入栈中；
  * 输出操作数 4；
  * 发现运算符 + 后，因为其优先级高于左括号，则直接存入栈中；
  * 输出操作符 7；
  * 发现右括号，依次输出当前栈内的元素 +；
  * 由于到达表达式末尾，则依次输出栈元素，此时输出 \*。

所以，上面四个表达式变成后缀表达式的结果就为：

![结果](<.gitbook/assets/image (8) (1).png>)
