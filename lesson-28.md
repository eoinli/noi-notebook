---
description: 进一步学习背包的程序思想，学习动态规划的基本原理，学会使用 C 语言风格输入输出
---

# Lesson 28

## 一、背包（二）

### 1.1 矿中取钻石（二）

在上节课的程序中，我们使用一个二维数组作为背包位完成了程序。这实际上导致空间复杂度增大到了 $$O(n^2)$$。这里我们来优化一下程序，使用一个一维数组实现相同的效果，使空间复杂度减小到 $$O(n)$$。

使用一维数组的方式并不难理解，就是每一轮循环中，在同一个数组里对数据进行操作。但是这样会导致一个问题，在处理数组中靠后的数据时，由于前面的数据已经被处理而修改过了，后面数据的处理结果会使用本轮循环中处理过的结果运算，会导致结果错误。这个问题的解决方法也很简单，每一次循环从后往前循环即可。

```cpp
#include <bits/stdc++.h>
#define N 1005
using namespace std;

int n, k, w[N], c[N], f[N]; // 减少了一维数组

int main() {
    
    cin >> k >> n;
    for (int i = 1; i <= n; i++) cin >> w[i] >> c[i];
    
    for (int i = 1; i <= n; i++)
        for (int j = k; j >= w[i]; j--) // 省去了判断装不装得下的步骤
            f[j] = max(f[j], f[j-w[i]] + c[i]);
            
    cout << f[k];
    
	return 0;
}
```

### 1.2 震后矿中取钻石

发现了钻石矿之后的一年内，Jeffery 家里的矿井经历了一场大地震。第二年 Jeffrey 下矿时，竟然发现之前发现的钻石矿又增加了！！！现在矿藏的每种不同钻石矿都有对应的价值 c（单位为万元）和质量 w（单位为克拉），每种钻石的总量是无限的。假设 Jeffrey 一次能够把矿里埋藏的总共 k 克拉钻石拿出来，且钻石不可以切割，问 Jeffrey 每年最多能用拿出的钻石换得多少万元额外收入？

#### 输入格式

第一行依次为两个正整数 k 和钻石的种类数量 n；

第二行至第 $$n+1$$ 行，每行依次为两个整数，分别代表该种钻石的总质量 w 和价值 c。

#### 输出格式

输出只有一行，代表 Jeffrey 可以通过卖钻石赚取的额外收入，保留一位小数。

#### 分析

这种情况属于**完全背包**。由于钻石总量是无限的，处理后面的数据时，使用前面的处理过的数据，因此不需要倒序遍历，直接正序遍历即可求出最优解。

#### 解答

```cpp
#include <bits/stdc++.h>
#define N 1005
using namespace std;

int n, k, w[N], c[N], f[N];

int main() {
    
    cin >> k >> n;
    for (int i = 1; i <= n; i++) cin >> w[i] >> c[i];
    
    for (int i = 1; i <= n; i++)
        for (int j = w[i]; j <= k; j++)
            f[j] = max(f[j], f[j-w[i]] + c[i]);
            
    cout << f[k];
    
	return 0;
}
```

## 二、动态规划

### 2.1 数字三角形

本题是 IOI 1994 年第一天的第一题。你可以在[洛谷（P1216）](https://www.luogu.com.cn/problem/P1216)、[OpenJudge（百练 2760）](http://bailian.openjudge.cn/practice/2760/)等 OJ 上找到本题。

#### 题目描述

观察下面的数字金字塔。

写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。

```
        7 
       /
      3   8 
     /
    8   1   0 
     \     
  2   7   4   4 
     /
4   5   2   6   5
```

在上面的样例中，从 $$7 \to 3 \to 8 \to 7 \to 5$$ 的路径产生了最大值 30。

#### 输入格式

第一个行一个正整数 r，表示行的数目。

后面每行为这个数字金字塔特定行包含的整数。

#### 输出格式

单独的一行，包含那个可能得到的最大的和。

#### 样例

**样例输入**

```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
```

**样例输出**

```
30
```

#### 数据范围

对于 100% 的数据，$$1\le r \le 1000$$，所有输入在 $$[0,100]$$ 范围内。

#### 分析

从倒数第二行开始，每一个元素都能作出两个和，分别是它本身与它左下方、右下方两个元素的和，在其中取最大值，就能保证路径的和最大。以样例数据为例，代码的运行过程就如下所示——

```
        30
       /
      23   21
     /
    20   13   10 
     \     
  7   12   10   10
     /
4   5    2    6    5
```

#### 解答

```cpp
#include <bits/stdc++.h>
#define N 1005
using namespace std;

int n, a[N][N];

int main() {
    
    cin >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= i; j++)
            cin >> a[i][j];
            
    for (int i = n-1; i >= 1; i--) // 从倒数第二行开始遍历
        for (int j = 1; j <= i; j++)
            a[i][j] += max(a[i+1][j], a[i+1][j+1]); // 数据取最大的和，不断向上
    
    cout << a[1][1];

	return 0;
}
```

## 三、C 语言风格输入输出

`scanf()` 与 `printf()` 函数包含在 `cstdio` 头文件中，分别是输入与输出函数。

### 3.1 `scanf()` 输入

```
int a; long long b; char c; float d; double e; unsigned long long f;
scanf("%d %lld %c %f %lf %llu", &a, &b, &c, &d, &e, &f);
```

使用 `scanf()` 输入的方式与 `cin` 很不相同。需要先自行判断需要输入的数据类型，并存入变量。输入字符串中的 `%` 为转义字符，表示后面的字符变为格式化字符。后面的变量中，每一个参数都与前面字符串中的格式化字符相匹配，分别表示前面输入的每一个数据会存入后面的变量中。注意后面作为参数的各个变量前面都要加上一个`&` 表示引用传值。

`scanf()` 输入的速度相比于 `cin` 提升了数十到数百倍，在处理大批量数据输入时的效率比 `cin` 好很多。如果遇到大量数据需要输入时，请一定记得使用 `scanf()` 以减少耗时。

在以上代码中，需要分别输入一个整数、一个 long long 类型整数、一个字符、一个单精度浮点数、一个双精度浮点数、一个无符号高精度整数，分别存入变量 `a`、`b`、`c`、`d`、`e`、`f`。

常用的输入占位符会在 3.3 节中列出。

### 3.2 `printf()` 输出

```
int a; long long b; char c; float d; double e; unsigned long long f;
scanf("%d %lld %c %f %lf %llu", &a, &b, &c, &d, &e, &f);
printf("%d %lld %c %f %lf %llu", a, b, c, d, e, f);
```

与 `scanf()` 相似，使用 `printf()` 输出时，字符串的语法也是使用占位符，且后面的每一个变量与前面的输出格式化字符一一对应。但这时不需要在作为参数的变量名前加上 `&`。

在以上代码中，程序会输出整数 `a`、long long 类型整数 `b`、字符 `c`、单精度浮点数 `d`、双精度浮点数 `e` 以及无符号高精度整数 `f`。另外，`printf()` 输出还有其他方便的输出占位符，将在 3.3 节中列出。

### 3.3 常用输入输出占位符

| 占位符     | 说明                                   |
| ------- | ------------------------------------ |
| `%d`    | 一个十进制整数                              |
| `%nd`   | 输出一个整数，如果不足 n 位，用空格补齐直到够 n 位（n 为正整数） |
| `%lld`  | 一个 long long 类型十进制整数                 |
| `%f`    | 读入一个单精度浮点数，或者输出一个单或双精度的浮点数           |
| `%lf`   | 读入一个双精度浮点数                           |
| `%.nlf` | 输出一个保留 n 位小数的浮点数（n 为正整数）             |
| `%c`    | 一个字符                                 |
| `\n`    | 输出换行符                                |
