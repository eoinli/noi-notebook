---
description: 继续学习、应用和优化深度优先搜索算法，学习广度优先搜索算法的程序思想并初步应用该算法
---

# Lesson 30

## 一、深度优先搜索（二）

### 1.1 数字三角形（二）

在[第 28 讲的第 2.1 节](lesson-28.md#2.1-shu-zi-san-jiao-xing)中，我们使用动态规划完成了数字三角形这道题。尽管这道题的思路并不是很难想，但是许多动态规划的题目都需要较高的思维逻辑，其规律并不容易想到。对于某些题目，这时候也可以通过深搜来完成，但是对于某些测试数据，传统深搜作出的结果会超出时间限制。**大部分效果都可以通过搜索解决，因为搜索的本质就是枚举。**所以，通常只有在完全想不到使用动态规划解题的思路时，我们可以使用深搜这种思路相对简单的算法，当作救命稻草，保住一些分数。

下面使用深搜的方法完成本题。在洛谷所给的测试数据中，使用深搜的做法只能通过五个测试点，而其余的四个测试点会超时。

按照深搜的思路，写深搜函数的时候需要关注以下几点：

* 何时终止搜索？
* 如何枚举每一种选择？
* 需要在搜索之后回溯

```cpp
# include <iostream>
# include <cstdio>
# define N 1005
using namespace std;

int n, a[N][N], cnt, maxn;

void dfs(int x, int y) {
    if (x > n) { // 如果到了最后一层以下则判断为到达了终点
        if (maxn < cnt) maxn = cnt; // 记录最大值
        return; // 终止函数
    } 
    for (int i = 0; i < 2; i++) { // 有两种走法，向右和向下
        int tx = x+1, ty = y+i; // 行数为当前数字加1的值，列数为i或i+1的值
        if (ty <= tx){ // 如果没有超出右边(这里无需考虑左、上以及下限)
            cnt += a[tx][ty]; // 增加和
            dfs(tx, ty); // 向下走
            cnt -= a[tx][ty]; // 回溯
        }
    }
    return; // 终止函数
}

int main () {
    
    cin >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= i; j++)
            cin >> a[i][j];
    
    cnt += a[1][1]; // 初始化
    dfs(1,1); // 进行搜索
    cout << maxn;

    return 0;
}
```

可以类比求斐波那契数列的递归函数，深搜需要进入的分支有很多，每一个分支的计算叠加在一起就会使运算量呈指数式增长。计算机的计算速度即使再快也是有限的，所以数据较大时，深搜的耗时就会延长，导致超时。

如果想要减少耗时，可以通过以下两种方式：

* 剪枝，即对于明显不符合条件的数据不进行搜索；
* 记忆化，即保存已经计算过的数据以便以后调用时不必再计算一遍。

### 1.2 矿中绝境（二）

#### 子任务四

如果 Jeffrey 能够走出矩阵，则输出他走出矩阵最少需要用多少步（移动一次就算一步）。

**分析**

可以给整个深搜函数增加一个 `step` 参数表示所用步数，在判断终点之前存步数最小值，然后每一次搜索就把步数加 1 当作参数传入下一级搜索函数，就可以求出到达终点时所用的最小步数。同时，我们在代码中使用了剪枝的方式简短搜索耗时。

```cpp
# include <iostream>
# include <climits>
# define N 105
using namespace std;

int map[N][N]; int n, cnt, mins = INT_MAX;
bool b[N][N];
int dx[4] = {-1, 0, 1, 0};
int dy[4] = {0, 1, 0, -1};

void dfs(int x, int y, int step) { // 增加步数参数
    if (step > mins) return; // 如果步数已经大于最小值则直接终止函数(剪枝)
    if (map[x][y] == 2) {
        if (mins > step) mins = step; // 打擂台存最小值
        return;
    }
    for (int i = 0; i < 4; i++) {
        int tx = x+dx[i], ty = y+dy[i];
        if (map[tx][ty] != 1 && tx >= 1 && tx <= n && ty >= 1 && ty <= n && !b[tx][ty]) {
            b[tx][ty] = 1;
            dfs(tx, ty, step+1); // 传入第三个参数为步数加1
            b[tx][ty] = 0;
        }
    }
    return;
}

int main () {
    
    cin >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            cin >> map[i][j];
    
    b[1][1] = 1;
    dfs(1, 1, 1); // 初始化步数为1
    cout << mins;
    return 0;
}
```

## 二、广度优先搜索

**广搜**（BFS），全称为**广度优先搜索**（breadth-first search），也是一种常用的搜索算法。与深搜相对，其过程简要来说是：从起点开始，沿着每条边搜索，直到到达终点。广搜的核心是：**系统地展开并检查图中的所有节点，以找寻结果**。

下面通过几道例题学习广搜的用法。

### 2.1 矿中绝境（三）

假设给出 $$7 \times 7$$ 矩阵地图——

```
0 1 1 0 0 1 0
0 0 0 0 1 1 0
1 0 1 0 1 1 0
1 0 0 0 0 0 0
0 0 1 0 1 1 0
1 0 1 0 2 0 0
0 0 0 0 1 1 1
```

我们知道，左上角为起点，`0` 表示可走路径，`1` 表示障碍物，`2` 表示终点。如果按照广搜的方式，那么搜索的顺序就会呈现下图的样子：

![](https://s3.bmp.ovh/imgs/2022/07/26/dc2b313251fd1f1f.png)

酒红色 `0` 为起点，此时只能向下走到红色 `0`，之后再向右走到橙色 `0`。此时橙色 `0` 共有两条路可走，都标上黄色。以此类推，只要能够到达终点 `2`，就一定能够搜索出一种走法。

#### 子任务四（二）

这道题的要求是找最短路径。请思考，当我们使用广搜，在地图上延伸了 n 次，找到了终点时，这条路径是最短路径吗？显然是的。因为前 $$n-1$$ 次延伸都没有到达终点，而第 n 次时找到了，说明找到终点的那条路径所花的步数一定小于其他任何路径到达终点的步数。所以这条路径就是最短的。

实现这一目标我们需要使用之前学习的队列和结构体的知识。队列能够用来模拟整个广度优先搜索过程，利用结构体数组来模拟队列。具体的模拟方法可以概括为：走到一个格子上就把这个格子加到队尾，同时删除队首的已经没有其他路可以走的格子。

拿上面的图举例来说：

* 先把 `(1,1)` 加入队列，走到 `(2,1)` 并将其加到队尾，因为 `(1,1)` 只有这一条路可以走，删去队首的 `(1,1)`；
* 加入 `(2,2)`，删去 `(2,1)`；
* 加入 `(2,3)` 和 `(3,2)`，删去 `(2,2)`；
* ……

```cpp
# include <iostream>
# define N 105
using namespace std;

int map[N][N], n;
int h = 1, t = 1; // 声明队首与队尾两个指针
bool b[N][N];
int dx[4] = {-1, 0, 1, 0};
int dy[4] = {0, 1, 0, -1};

struct node {
    int x, y, step;
} data[N*N]; // 定义结构体数组，用来模拟队列，队列中的每个元素分别有x、y坐标和到当前格子所花的步数这三个属性

int main () {
    
    cin >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            cin >> map[i][j]; // 输入矩阵信息
            
    b[1][1] = 1; // 初始化起点为已走过
    data[t].x = data[t].y = data[t].step = 1; // 将队列中作为起点的第一个格子的坐标与步数统一初始化为1
    while (h <= t) { // 判断队首是否小于或等于队尾元素，如果是则可以进行搜索
        if (map[data[h].x][data[h].y] == 2) { // 如果队首元素已经为终点
            cout << data[h].step; // 就输出截止当前所花的步数(这个数值是最少步数)
            return 0; // 因为已经到达了终点，所以终止程序
        }
        for (int i = 0; i < 4; i++) {
            int tx = data[h].x + dx[i];
            int ty = data[h].y + dy[i];
            int ts = data[h].step + 1; // 循环四种走法，分别存储下一个格子的x坐标、y坐标和到下一格格子所花的步数
            if (map[tx][ty] != 1 && 
                tx >= 1 && tx <= n && 
                ty >= 1 && ty <= n &&
                b[tx][ty] == 0) { // 如果满足可以走的条件(不为障碍物、在边界内、没有走过)
                b[tx][ty] = 1; // 标记下一个格子为已走过
                t++; // 下一个格子作为队尾元素加1，表示走到了下一个格子上
                data[t].x = tx;
                data[t].y = ty;
                data[t].step = ts; // 分别把队尾元素的三个属性赋值回数组中
            }
        }
        h++; // 将队首元素向后移一位，继续循环搜索
    }
    cout << "-1"; // 如果搜索完了都没有到达终点，则输出-1

    return 0;
}
```
