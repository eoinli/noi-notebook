---
description: 认识递归，了解其三要素并学习包含递归函数的经典程序
---

# Lesson 19

## 一、递归

**递归**（Recursion）指的是函数在运行过程中自己调用自己的行为。

### 1.1 递归函数的三要素

1. 递归要有**终点**。如果不给递归函数设定停止条件，它就会不断调用自己，像死循环一样，直到占满分配给它的内存。
2. 使用递归需要**不断减小问题的规模**。使用递归的目的是更简便地解决问题，所以每一次递归都需要对上一次递归中的问题进行拆分。
3. 每一次递归的行为**相同**。由于递归函数自身对自身进行调用，所以每一次递归所进行的操作一定一致的。

### 1.2 递归的应用

#### 1.2.1 楼梯问题

现有 n 级台阶，上楼可以一步上一级台阶，也可以一步上两级，请计算上到第 n 级台阶共有多少种不同的走法。

**分析**

想要走到第 5 级台阶，那么一定要先走到第 4 或第 3 级台阶。走到第 4 级台阶，一定要先走到第 3 或第 2 级台阶；走到第三季台阶，一定要走到第 2 级和第 1 级台阶。可见，走到第 n 级台阶的走法，是走到前 1 和前 2 级台阶（第 n-1 和第 n-2 级台阶）的走法之和。所以，如果我们将递归的终点设为第 1 和第 2 级台阶，当 $$n \ge 3$$ 时则使用递归计算前两级台阶的走法之和，就可以计算出走到第 n 级台阶的走法数量。

**代码**

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;

int step(int i) {
    if (i == 1) return 1; // 如果参数为1则有1种走法
    if (i == 2) return 2; // 如果参数为2则有2种走法
    else return step(i-1) + step(i-2); // 否则走法数为前2级台阶的走法数之和
}

int main() {
    
    cin >> n;
    cout << step(n);
	return 0;
}
```

#### 1.2.2 斐波那契数列

假定小兔子一个月可以长成大兔子，大兔子每个月生产一对小兔子。如果年初养了一对小兔子，若兔子不会死亡，那么 n 个月后将有多少对兔子？

**分析**

| 月份 | 小兔子对数 | 大兔子对数 | 兔子总对数 |
| -- | ----- | ----- | ----- |
| 1  | 1     | 0     | 1+0=1 |
| 2  | 0     | 1+0=1 | 0+1=1 |
| 3  | 1     | 0+1=1 | 1+1=2 |
| 4  | 1     | 1+1=2 | 1+2=3 |
| 5  | 2     | 1+2=3 | 2+3=5 |
| 6  | 3     | 2+3=5 | 3+5=8 |
| …… | ……    | ……    | ……    |

如果把每个月兔子对数的情况列成表，则可以发现，从第 2 个月开始，第 n 个月的大兔子对数等于第 $n-1$ 个月的大小兔子对数之和，第 n 个月的小兔子对数等于第 $$n-1$$ 个月的大兔子对数。

可以发现总对数的规律是：对于第 n 个月（$$n\le 2$$），兔子的总对数均为 1；对于第 n 个月（$$n\ge 3$$），兔子的总对数等于第 $$n-1$$ 和 $$n-2$$ 个月的兔子总对数之和。

**代码**

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;

int hare(int i) {
    if (i == 1 || i == 2) return 1; // 前两个月有1对兔子
    return hare(i-1) + hare(i-2); // 之后的每个月兔子等于前两个月兔子总数之和
}

int main() {
    
    cin >> n;
    
    cout << hare(n);
    
	return 0;
}
```

#### 1.2.3 牛的生殖

一头母牛出生之后，第四年可以生出一头小母牛。现有一头刚出生的小母牛，若牛不会死亡，问 n 年后，一共有多少头牛？

**分析**

| 年数 | 一岁小牛 | 两岁小牛 | 三岁小牛 | 母牛 | 总数         |
| -- | ---- | ---- | ---- | -- | ---------- |
| 1  | 1    | 0    | 0    | 0  | 1          |
| 2  | 0    | 1    | 0    | 0  | 1          |
| 3  | 0    | 0    | 1    | 0  | 1          |
| 4  | 1    | 0    | 0    | 1  | 2 = 1 + 1  |
| 5  | 1    | 1    | 0    | 1  | 3 = 1 + 2  |
| 6  | 1    | 1    | 1    | 1  | 4 = 1 + 3  |
| 7  | 2    | 1    | 1    | 2  | 6 = 2 + 4  |
| 8  | 3    | 2    | 1    | 3  | 9 = 3 + 6  |
| 9  | 4    | 3    | 2    | 4  | 13 = 4 + 9 |
| …… | ……   | ……   | ……   | …… | ……         |

如果把每年牛头数的情况列成表，则可以发现，从第 2 年开始，第 n 年一岁小牛的数量等于第 $$n-1$$ 年母牛的数量，两岁小牛的数量等于第 $$n-1$$ 年一岁小牛的数量，三岁小牛的数量等于第 $$n-1$$ 年两岁小牛的数量，母牛的数量等于第 $$n-1$$ 年母牛的数量和三岁小牛的数量之和。

可以发现总头数的规律是：对于第 n 年（$$n\le 3$$），牛的总头数均为 1；对于第 n 年（$$n\ge 4$$），牛的总头数等于第 $$n-1$$ 和 $$n-3$$ 年的牛总头数之和。

**代码**

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;

int cattle(int i) {
    if (i == 1 || i == 2 || i == 3) return 1; // 前三年只有一头牛
    return cattle(i-1) + cattle(i-3); // 之后的每年牛数量等于前一年和前三年牛数量之和
}

int main() {
    
    cin >> n;
    
    cout << cattle(n);
    
	return 0;
}
```

#### 1.2.4 汉诺塔

有三根杆子 A、B、C。A 杆上有 n 个穿孔圆盘，盘的尺寸由下到上依次变小。规定每次只能移动一个圆盘、大盘不能叠在小盘上面。请求出将所有圆盘移至 C 杆至少需要的移动圆盘的次数。

**分析**

我们把汉诺塔中现有的三根杆子分别称为：**起始杆**、**过渡杆**和**目标杆**。现在有 n 个圆盘，它们按照从下到上、从大到小的顺序排列在起始杆上。

考虑这 n 个圆盘中靠上的 $$n-1$$ 个圆盘，我们可以通过 m 次操作使得这 $$n-1$$ 个圆盘从起始杆移动到过渡杆上，之后直接把起始杆上剩下的最大的圆盘通过 1 次操作移动到目标杆上。接着，对于过渡杆上的这 $$n-1$$ 个圆盘，再通过 m 次操作把它们移动到目标杆的最大的圆盘之上。

在这 m 次操作（以移动剩下的最大圆盘之**后**的 m 次操作为例）中，我们可以将这 $$n-1$$ 个圆盘所在的过渡杆看作一个新汉诺塔系统里的起始杆，将其中靠上的 $$(n-1)-1$$ 个圆盘通过 k 次操作移动到新系统中的过渡杆（也就是原来系统里的起始杆）上，之后直接把新系统起始杆上剩下的那一个圆盘通过一次操作移动到新系统的目标杆（也就是原来系统的目标杆）上。接着，对于新系统过渡杆上的这 $$(n-1)-1$$ 个圆盘，再通过 k 次操作把它们移动到新系统目标杆的圆盘之上。

在这 k 次操作中，我们又可以将这 $$(n-1)-1$$ 个圆盘所在的过渡杆看作一个新新汉诺塔系统里的起始杆。以此类推，直到当前系统的过渡杆上只剩下一个圆盘的时候为止。

使用递归求解，就是把每一个汉诺塔系统看成递归函数的一层，而每一个汉诺塔系统都包含着一个内部的汉诺塔系统，正好符合递归的性质。
