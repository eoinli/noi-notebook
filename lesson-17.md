---
description: 通过历年 NOI 真题学习 STL 排序和桶排序
---

# Lesson 17

{% hint style="info" %}
请注意，在本页面所显示的代码段中，可能出现行内缩进过多或过少等现象，这是不同笔记软件和集成开发环境所预设的制表符长度不同所导致的，属正常现象。
{% endhint %}

## 一、排序

### 1.1 明明的随机数

本题是 2006 年 NOIP 普及组真题。你可以在[洛谷（P1059）](https://www.luogu.com.cn/problem/P1059)、[OpenJudge（1.10.09）](http://noi.openjudge.cn/ch0110/09/)等 OJ 上找到本题。

#### 题目描述

明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 N 个 1 到 1000 之间的随机整数（$$N \le 100$$），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。

#### 输入格式

输入有两行，第 1 行为 1 个正整数，表示所生成的随机数的个数 N

第 2 行有 N 个用空格隔开的正整数，为所产生的随机数。

#### 输出格式

输出也是两行，第 1 行为 1 个正整数 M ，表示不相同的随机数的个数。

第 2 行为 M 个用空格隔开的正整数，为从小到大排好序的不相同的随机数。

#### 样例

**样例输入**

```
10
20 40 32 67 40 20 89 300 400 15
```

**样例输出**

```
8
15 20 32 40 67 89 300 400
```

#### 解答

**解法一：一般解法**

先对所有输入数据进行排序，输出时相同的数据只输出一个，即判断当前数据与前一个数据是否相同。

```cpp
#include <bits/stdc++.h>
using namespace std;

int a[1005] = {0}, n, cnt = 0;

int main() {
	cin >> n;
	
	for (int i = 1; i <= n; i++)
		cin >> a[i]; // 先输入数据

	sort(a+1, a+n+1); // 对数据进行升序排序
	
	for (int i = 1; i <= n; i++) 
		if (a[i] != a[i-1]) cnt++; // 如果排序后的数据中同一种数据出现了多次，不计数

	cout << cnt << endl;
	
	for (int i = 1; i <= n; i++) {
		if (a[i] == a[i-1]) continue; // 如果与前一个数据相同则忽略
		cout << a[i] << " "; // 否则输出数据
	}
	return 0;
}
```

#### 解法二：桶排序

输入时判断这个数字是否出现过，如果出现过则忽略，如果没有出现过则将该数字存入数组相应下标的位置中。也就是说，这个数组的每一个位置最大值只能是 1，这样就可以保证不会重复。输出时将数据范围内所有标记为 1（已出现过）的数字输出即可。

桶排序是最快的排序类型，可以用来排序以及去重；但是它的缺点在于，所排序数字的范围有多大，使用桶排序需要开的数组就有多大。一般来说，桶排序允许的数据最大不超过 $$1\times10^{6}$$。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, a[1005] = {0}, cnt = 0, t;

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) { // 这里用while(n--)循环亦可
		cin >> t; // 输入给临时变量
		if (a[t]) continue; // 如果该位置的数字已经出现过，则跳过循环
		cnt++; // 否则增加计数
		a[t]++; // 并将在当前位置的数字标记为1，即已出现过
	}
	cout << cnt << endl;
	for (int i = 1; i <= 1000; i++)
		if (a[i]) cout << i << " "; // 如果位置i的数字已经出现过，则输出i
	return 0;
}
```

### 1.2 奖学金

本题是 2007 年 NOIP 普及组真题。你可以在[洛谷（P1093）](https://www.luogu.com.cn/problem/P1093)、[OpenJudge（1.10.04）](http://noi.openjudge.cn/ch0110/04/)等 OJ 上找到本题。

#### 题目描述

某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前 5 名学生发奖学金。期末，每个学生都有 3 门课的成绩：语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学排在前面，这样，每个学生的排序是唯一确定的。

任务：先根据输入的 3 门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前五名名学生的学号和总分。注意，在前 5 名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据（每行输出两个数：学号、总分）是:

```
7 279
5 279
```

这两行数据的含义是：总分最高的两个同学的学号依次是 7 号、5 号。这两名同学的总分都是 279（总分等于输入的语文、数学、英语三科成绩之和），但学号为 7 的学生语文成绩更高一些。如果你的前两名的输出数据是：

```
5 279
7 279
```

则按输出错误处理，不能得分。

#### 输入格式

共 n+1 行。

第 1 行为一个正整数 $$n( \le 300)$$，表示该校参加评选的学生人数。

第 2 到 n+1 行，每行有 3 个用空格隔开的数字，每个数字都在 0 到 100 之间。第 j 行的 3 个数字依次表示学号为 j-1 的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为 1\~n（恰好是输入数据的行号减 1）。

#### 输出格式

共 5 行，每行是两个用空格隔开的正整数，依次表示前 5 名学生的学号和总分。

#### 样例一

**样例输入一**

```
6
90 67 80
87 66 91
78 89 91
88 99 77
67 89 64
78 89 98
```

**样例输出二**

```
6 265
4 264
3 258
2 244
1 237
```

#### 样例二

**样例输入二**

```
8
80 89 89
88 98 78
90 67 80
87 66 91
78 89 91
88 99 77
67 89 64
78 89 98
```

**样例输出二**

```
8 265
2 264
6 264
1 258
5 258
```

#### 解答

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;

struct score {
	int c, m, e, tot, id;
}stu[305];

bool cmp(score a, score b) {
	if (a.tot != b.tot) return a.tot > b.tot; // 如果总分不同，则总分降序排列
	if (a.c != b.c) return a.c > b.c; // 如果总分相同但语文成绩不同，则语文成绩降序排列
	return a.id < b.id; // 如果总分和语文成绩都相同，则学号升序排列
}

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> stu[i].c >> stu[i].m >> stu[i].e; // 分别输入语数外三科成绩
		stu[i].tot = stu[i].c + stu[i].m + stu[i].e; // 计算总分
		stu[i].id = i; // 设定学号
	}
		
	sort(stu+1, stu+n+1, cmp); // 按规则排序
	for (int i = 1; i <= 5; i++) // 输出前五位
		cout << stu[i].id << " " << stu[i].tot << endl;
	return 0;
}
```

### 1.3 谁拿了最多奖学金

本题是 2005 年 NOIP 提高组真题。你可以在[洛谷（P1051）](https://www.luogu.com.cn/problem/P1051)、[OpenJudge（1.9.04）](http://noi.openjudge.cn/ch0109/04/)等 OJ 上上找到本题。

#### 题目描述

某校的惯例是在每学期的期末考试之后发放奖学金。发放的奖学金共有五种，获取的条件各自不同：

1. 院士奖学金，每人 8000 元，期末平均成绩高于 80 分，并且在本学期内发表 1 篇或 1 篇以上论文的学生均可获得；
2. 五四奖学金，每人 4000 元，期末平均成绩高于 85 分，并且班级评议成绩高于 80 分的学生均可获得；
3. 成绩优秀奖，每人 2000 元，期末平均成绩高于 90 分的学生均可获得；
4. 西部奖学金，每人 1000 元，期末平均成绩高于 85 分的西部省份学生均可获得；
5. 班级贡献奖，每人 850 元，班级评议成绩高于 80 分的学生干部均可获得；

只要符合条件就可以得奖，每项奖学金的获奖人数没有限制，每名学生也可以同时获得多项奖学金。例如姚林的期末平均成绩是 87 分，班级评议成绩 82 分，同时他还是一位学生干部，那么他可以同时获得五四奖学金和班级贡献奖，奖金总数是 4850 元。

现在给出若干学生的相关数据，请计算哪些同学获得的奖金总数最高（假设总有同学能满足获得奖学金的条件）。

#### 输入格式

第一行是 1 个整数 N（$$1 \le N \le 100$$），表示学生的总数。

接下来的 N 行每行是一位学生的数据，从左向右依次是姓名，期末平均成绩，班级评议成绩，是否是学生干部，是否是西部省份学生，以及发表的论文数。姓名是由大小写英文字母组成的长度不超过 20 的字符串（不含空格）；期末平均成绩和班级评议成绩都是 0 到 100 之间的整数（包括 0 和 100）；是否是学生干部和是否是西部省份学生分别用 1 个字符表示，$$\tt Y$$ 表示是，$$\tt N$$ 表示不是；发表的论文数是 0 到 10 的整数（包括 0 和 10）。每两个相邻数据项之间用一个空格分隔。

#### 输出格式

共 3 行。

* 第 1 行是获得最多奖金的学生的姓名。
* 第 2 行是这名学生获得的奖金总数。如果有两位或两位以上的学生获得的奖金最多，输出他们之中在输入文件中出现最早的学生的姓名。
* 第 3 行是这 N 个学生获得的奖学金的总数。

#### 样例

**样例输入**

```
4
YaoLin 87 82 Y N 0
ChenRuiyi 88 78 N Y 1
LiXin 92 88 N N 0
ZhangQin 83 87 Y N 1
```

**样例输出**

```
ChenRuiyi
9000
28700
```

#### 解答

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, sum;

struct scholarship {
	string name;
	int grad, inc, essay, id;
	char prof, west;
	int scho = 0;
} stu[105];

bool cmp(scholarship a, scholarship b) {
	if (a.scho != b.scho) return a.scho > b.scho;
	return a.id < b.id;
}

int main() {
	
	cin >> n;
	
	for (int i = 1; i <= n; i++) {
		cin >> stu[i].name >> stu[i].grad >> stu[i].inc >> stu[i].prof >> stu[i].west >> stu[i].essay;
		stu[i].id = i;
		if (stu[i].grad > 80   && stu[i].essay >= 1) 	stu[i].scho += 8000;
		if (stu[i].grad > 85   && stu[i].inc > 80) 	stu[i].scho += 4000;
		if (stu[i].grad > 90)                       	stu[i].scho += 2000;
		if (stu[i].west == 'Y' && stu[i].grad > 85) 	stu[i].scho += 1000;
		if (stu[i].inc > 80    && stu[i].prof == 'Y')	stu[i].scho += 850;
		sum += stu[i].scho;
	}
		
	sort(stu+1, stu+n+1, cmp);
	
	cout << stu[1].name << endl;
	cout << stu[1].scho << endl;
	cout << sum;
	
	return 0;
}
```
