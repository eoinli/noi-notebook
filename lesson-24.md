---
description: 了解信息学有关内容，学习有关计算机的基础知识
---

# Lesson 24

## 一、信息学与信息学奥赛

### 1.1 信息学的历史

1948 年，美国数学家**克劳德·香农**（Claude Shannon）提出了**信息论**（information theory），建立了**信息熵**（entropy）的概念，因此被称为信息论的创始人。二战期间，**艾伦·图灵**（Alan Turing）发明了第一台概念上的计算机，他被誉为计算机科学与人工智能之父。当前信息学界的最高奖项就是**图灵奖**。此后，**冯·诺依曼**（Von Neumann）又提出了一种著名的计算机架构，被称为**冯·诺依曼架构**，它在现在的计算机中得到了广泛应用。

### 1.2 信息学奥林匹克竞赛

* **国际信息学奥林匹克竞赛**（International Olympiad in Informatics），简称 IOI；
* **全国青少年信息学奥林匹克竞赛**（National Olympiad in Informatics），简称 NOI；
* **全国青少年信息学奥林匹克联赛**（National Olympiad in Informatics in Provinces），简称 NOIP；
* **中国计算机学会**（China Computer Federation），简称 CCF。

## 二、计算机基础

### 2.1 计算机基本组成

* **电子管**（vacuum tube），是一种最早期的电信号放大器件；
* **晶体管**（transistor），是一种固体半导体器件；
* **小规模集成电路**（small scale integration），是一种将少量晶体管组合到单一芯片的集成电路。
* **超大规模集成电路**（very large scale integration），是一种将大量晶体管组合到单一芯片的集成电路。

### 2.2 冯·诺依曼架构

冯·诺依曼架构的基本结构如下图所示（图片需要联网）——

![冯·诺依曼架构简图](<.gitbook/assets/image (8).png>)

### 2.3 RAM 与 ROM

* **随机存取存储器**（random access memory），简称为 RAM，是与 CPU 直接交换数据的内部存储器。它可以随时读写，而且速度很快，通常作为操作系统或其他正在运行中的程序的临时资料存储介质；
* **只读存储器**（read-only memory），简称为 ROM，是一种半导体存储器，其特点是一旦在其体内存储了资料就无法再被改写或删除，但其存储过的内容也不会因为电源关闭而丢失。只读存储器非常适合那些在生命周期中几乎不会被更改的软件。

RAM 是易失性内存，用于暂时存储**正在处理的文件**。ROM 是非易失性内存，用于**为电脑长久存储指令**。

### 2.4 存储金字塔

寄存器 > 高速缓存 > 内存 > 外存

### 2.5 程序结构

程序结构分为三种，即**顺序结构**、**分支结构**以及**循环结构**。

### 2.6 三种总线

#### 2.6.1 数据总线

1. 是 CPU 与内存或其他器件之间的数据传送的通道；
2. 数据总线的宽度决定了 CPU 和外界的数据传送速度；
3. 每条传输线一次只能传输 1 位二进制数据。

#### 2.6.2 地址总线

1. CPU 是通过地址总线来指定存储单元的；
2. 地址总线决定了 CPU 所能访问的最大内存空间的大小。

#### 2.6.3 控制总线

1. CPU通过控制总线对外部器件进行控制；
2. 控制总线的宽度决定了CPU对外部器件的控制能力。

### 2.7 计算机数字表达

#### 2.7.1 原码

一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号，正数为 0，负数为 1。为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。原码是人脑最容易理解和计算的表示方式。

例如——

```
+1 的二进制原码为 00000001
-1 的二进制原码为 10000001

+45 的二进制原码为 00101101
-45 的二进制原码为 10101101
```

#### 2.7.2 反码

反码的表示方法是：

* 正数的反码是其本身；
* 负数的反码是在其原码的基础上，符号位不变，其余各位取反。

例如——

```
+1 的二进制反码为 00000001
-1 的二进制反码为 11111110

+45 的二进制反码为 00101101
-45 的二进制反码为 11010010
```

可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值，通常要将其转换成原码再计算。

#### 2.7.3 补码

补码的表示方法是：

* 正数的补码是其本身；
* 负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后加 1（即在反码的基础上加 1）。

例如——

```
+1 的二进制补码为 00000001
-1 的二进制补码为 11111111

+45 的二进制补码为 00101101
-45 的二进制补码为 11010011
```

对于负数，补码表示方式也是人脑无法直观看出其数值的，通常也需要转换成原码在计算其数值。

#### 2.7.4 归纳

一个正数的原码、反码和补码就是其本身。一个负数的原码是其绝对值的原码符号位变为 1 后的值。一个负数的反码是在其原码的基础上，符号位不变，其余各位取反。一个负数的原码是其反码加 1 后的值。

若要求一个数的十六进制原、反、补码，先将其转换为二进制数，得出其原、反、补码后再转为十六进制数即可。

### 2.8 逻辑表达式

C++ 中的逻辑运算符与、或、非分别是 `&&`、`||`、`!`。而在非代码环境中，逻辑运算符可以写作如下形式：

* 与：∧
* 或：∨
* 非：$$\lnot$$

如逻辑表达式 $$(A ∨ B)∧ \lnot A$$ 可以写成 C++ 代码 `(A||B)&&!A`。

### 2.9 位运算

位运算与逻辑运算不同。我们通过一个例子了解位运算的规则。

请看表达式 $$(23 ∨ 2) \oplus 5$$。

括号内的 $$23 ∨ 2$$ 可以这样计算：

1. 将 23 和 2 分别转换为二进制，则为 10111 和 10；
2. ```
   1 0 1 1 1
   0 0 0 1 0
   ---------
   1 0 1 1 1 // 或运算的规则是：当前数位上，只要有一个数为1，
             // 得出结果的这一位就为1，否则为0
   ```

于是 $$23 ∨ 2$$ 的结果就为 23。再进行 $$23 \oplus 5$$ 运算：

1. 将 23 和 5 分别转换为二进制，则为 10111 和 101；
2. ```
   1 0 1 1 1
   0 0 1 0 1
   ---------
   1 0 0 1 0 // 异或运算的规则是：当前数位上，只要进行运算的两个数不同，
             // 得出结果的这一位就为1，否则为0
   ```

所以最终结果就是 $$10010_{(2)}$$，转换为十进制数为 18。

* 与运算的规则：当前数位上，两个数都为 1，得出结果的这一位才为 1，否则为 0；
* 非运算的规则：当前数位上数字为 1，则结果为 0，反之亦然。
