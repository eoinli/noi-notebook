---
description: 进一步学习并理解递归算法及其优化方式，初步学习高精度数和高精度加法运算
---

# Lesson 20

## 一、递归（二）

### 1.1 递归的应用（二）

#### 1.1.1 汉诺塔（二）

有三根杆子 A、B、C。A 杆上有 n 个穿孔圆盘，盘的尺寸由下到上依次变小。规定每次只能移动一个圆盘、大盘不能叠在小盘上面。请求出将所有圆盘移至 C 杆至少需要的移动圆盘的次数和每一步的移动方式。

**分析**

我们把汉诺塔中现有的三根杆子分别称为：**起始杆**、**过渡杆**和**目标杆**。现在有 n 个圆盘，它们按照从下到上、从大到小的顺序排列在起始杆上。

考虑这 n 个圆盘中靠上的 $$n-1$$ 个圆盘，我们可以通过 m 次操作使得这 $$n-1$$ 个圆盘从起始杆移动到过渡杆上，之后直接把起始杆上剩下的最大的圆盘通过 1 次操作移动到目标杆上。接着，对于过渡杆上的这 $$n-1$$ 个圆盘，再通过 m 次操作把它们移动到目标杆的最大的圆盘之上。

在这 m 次操作（以移动剩下的最大圆盘之**后**的 m 次操作为例）中，我们可以将这 $$n-1$$ 个圆盘所在的过渡杆看作一个新汉诺塔系统里的起始杆，将其中靠上的 $$(n-1)-1$$ 个圆盘通过 k 次操作移动到新系统中的过渡杆（也就是原来系统里的起始杆）上，之后直接把新系统起始杆上剩下的那一个圆盘通过一次操作移动到新系统的目标杆（也就是原来系统的目标杆）上。接着，对于新系统过渡杆上的这 $$(n-1)-1$$ 个圆盘，再通过 k 次操作把它们移动到新系统目标杆的圆盘之上。

在这 k 次操作中，我们又可以将这 $$(n-1)-1$$ 个圆盘所在的过渡杆看作一个新新汉诺塔系统里的起始杆。以此类推，直到当前系统的过渡杆上只剩下一个圆盘的时候为止。

使用递归求解，就是把每一个汉诺塔系统看成递归函数的一层，而每一个汉诺塔系统都包含着一个内部的汉诺塔系统，正好符合递归的性质。

**代码（求最少次数）**

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;

int hanoi(int i){
    if (!i) return 0; // 如果输入0则自动退出函数
    if (i==1) return 1; // 如果输入1则返回次数为1
    return 2*hanoi(i-1) + 1; // 新系统需要从起始移到过渡再移到目标
                             // 之间还有一次大圆盘的挪移
}

int main() {
    cin >> n;
    cout << hanoi(n);    
	return 0;
}
```

**代码（求每一步移动方式）**

```cpp
#include <bits/stdc++.h>
using namespace std;

int k, n;

void hanoi(int i, char from, char buffer, char to){
    if (!i) return ; // 如果输入0则自动退出函数
    hanoi(i-1, from, to, buffer); // 将原系统的过渡杆和目标杆在新系统中互换
    k++; // 计次
    cout << k << ":" << "\t" << from << " " << to << endl; // 输出
    hanoi(i-1, buffer, from, to); // 互换（原→新）起→过；目→起；过→目
}

int main() {
    cin >> n;
    hanoi(n, 'a', 'b', 'c');    
	return 0;
}
```

#### 1.1.2 球放盘子

把 m 个同样的小球放在 n 个同样的盘子里，允许盘子里空着，问有多少种分法（同种分法互换位置不算）。

**分析**

该问题使用递推解决，从递归的三要素出发，在思路上有两个难点：

* 递归的结束条件：$$m=0$$ 或 $$n=1$$ 时，分法只有 1 种；
* 递归如何减少问题的规模：分类讨论 $$n \gt m$$ 和 $$n \le m$$ 的情况。

**代码**

```cpp
#include <bits/stdc++.h>
using namespace std;

int i, j;

int plate(int m, int n) {
    // 小球数量为0或盘子数量为1
    if (!m || n==1) return 1;
    // 小球数量小于盘子数量，则其分法与小球数量等于盘子数量时的分法数量相等
    if (m < n) return plate(m, m);
    // 小球数量不小于盘子数量，则分类讨论有空盘和无空盘（每盘内至少有一个小球）的情况
    return plate(m, n-1) + plate(m-n, n);
}

int main() {
    cin >> i >> j;
    cout << plate(i, j);
	return 0;
}
```

#### 1.1.3 求最大公约数

给定两个正整数 m 和 n，求它们的最大公约数（greatest common divisor）。

**分析**

假设 m 和 n 的最大公约数为 x，x 具有这样的特点：

* x 可以整除 m；
* x 可以整除 n；
* x 可以整除 m 除以 n 的余数。

**代码**

```cpp
#include <bits/stdc++.h>
using namespace std;

int m, n;

int gcd(int x, int y) {
    if (!(x%y)) return y; // 如果可以直接整除则返回y
    return gcd(y, x%y); // 否则将参数设为y和余数进行递归
}

int main() {
    cin >> m >> n;
    cout << gcd(m, n);
	return 0;
}
```

### 1.2 递归的理解与优化

请看以下程序，试分析程序的运行流程并计算最终输出的结果。

```cpp
#include <bits/stdc++.h>
using namespace std;

int f(int n) {
    if (n==1) return 1;
    if (n==2) return 2;
    return f(n-1) - f(n-2);
}

int main() {
    cout << f(7);
	return 0;
}
```

请看以下计算过程：

$$
f(1) = 1\\ f(2) = 2\\ f(3) = f(2)-f(1) = 2-1 = 1 \\ f(4) = f(3)-f(2) = 1-2 = -1\\ f(5) = f(4)-f(3) = -1-1 = -2\\ f(6) = f(5)-f(4) = -2-(-1) = -1\\ f(7) = f(6)-f(5) = -1-(-2) = 1
$$

输入值为 7 时，计算机很容易地用不到一秒的时间就算出了答案。但是，当输入值越来越大，达到 40、50 或以上时，程序运行的时间就会延长许多倍，甚至几十倍、几百倍。原因时，以上面的计算过程为例，如果需要计算 $$f(5)$$ 的值，则需要计算两遍 $$f(3)$$ 的值，也就是说运行的耗时也翻了一倍。在这种情况下，如果需要简短计算耗时，可以将计算过的数据存起来，之后的计算中直接调用存储的结果即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

int a[10005] = {0, 1, 2}; // 定义数组来存储计算结果

int f(int i) {
    
    if (a[i]) return a[i]; // 如果已经计算过则直接返回数组中存储的值
    else
        return a[i] = f(i-1) - f(i-2); // 否则把数组当前元素设为计算结果
}

int main() {
    cout << f(10000);
	return 0;
}
```

## 二、高精度

顾名思义，高精度运算的精度很高。一般情况下，我们使用的 `int` 数据类型存储的数字已经不小了，但是如果需要计算几个 100 多位的数字，就连 `unsigned long long` 类型都无法存储的话，就需要使用高精度计算。此外，小数部分过长的浮点数，由于精度要求高，也没有办法使用 `double` 存储，因此也要通过高精度数才能存储。

### 2.1 高精度加法

高精度加法中，我们需要对数字的每一位单独进行运算。我们可以通过数组来模拟非常长的整数。

#### 2.1.1 头文件 vector

**Vector**，本义是向量、矢量，在 C++ 中作为头文件则可以用来定义一个不限制长度的变量、数组或函数。这就是说，在声明时不用为其分配空间。使用时需要引入 `vector` 头文件，写法如下：

```cpp
#include<vector>
vector<数据类型> 变量或数组名;
vector<数据类型> 函数名(参数) {
    // 执行语句
}
```

如，声明一个不限长度的 `int` 类型数组 `array`，需要使用以下代码。

```cpp
#include<vector>
vector<int> array;
```

#### 2.1.2 存储高精度数字

在输入时，我们可以先借助 `string` 类型，把输入数据分装在两个字符串中。

请思考一下：在进行加法运算时，两个加数的数位对应关系是怎样的？显然是个位对个位、十位对十位这样以此类推下去，就算到达了第一百位也是如此。然而在正序数组中，想要实现这样的效果并不容易。为此，我们可以将刚才存储的字符串中的每一位**倒序**放进数组的每一元素的位置，这样就可以保证数位对齐。

这里会使用到一个新的函数（包含在 `vector` 头文件中）—— `push_back()`。它的作用是把一个数据添加到一个 `vector` 数组的尾部。用法如下——

```cpp
vectorArray.push_back(element)
```

`vectorArray` 是需要添加数据的 `vector` 数组，`element` 是要添加的元素。

此外，由于 `vector` 数组没有指定长度，不能用 `.length()` 获取元素长度，但是可以用 `.size()` 获取（取字符串长度也可以使用 `.size()`）。

核心代码如下：

```cpp
string a, b;
vector<int> A, B;

// ...

int main() {
    cin >> a >> b;
    for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');
    for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0');
    vector<int> C = add(A, B);
    for (int i = C.size() - 1; i >= 0; i--) cout << C[i];
    return 0;
}
```

我们输入字符串 `a` 和 `b` 后，倒序把其中的每一位转化成 `int` 类型的单位数字（即减去字符 0 的 ASCII 码），添加到 `vector` 数组 `A` 和 `B` 的尾部。此后，我们声明一个新的 `vector` 数组 `C` 来存储二者之和（函数 `add()` 的操作将会在下一节中讲解，作用是处理两个高精度数的加法运算），最后再把数组 `C` 倒序输出以获得正序的计算结果。

#### 2.1.3 计算高精度加法

高精度加法的运算实际上和竖式加法比较类似，都是各位处理各位的和，同时处理向前进位的情况。计算高精度加法时也是这样。

核心代码如下：

```cpp
vector<int> add(vector<int> X, vector<int> Y) {
    if (X.size() < Y.size()) return add(Y, X);
    int t = 0;
    vector<int> Z;
    for (int i = 0; i < X.size(); i++) {
        t += X[i];
        if (i < Y.size()) t += Y[i];
        Z.push_back(t%10);
        t /= 10;
    }
    if (t) Z.push_back(t);
    return Z;
}
```

在这个 `vector` 函数中，两个参数 `X` 和 `Y`，分别表示两个高精度数。在执行其他操作之前，如果 `X` 的位数比 `Y` 要多，则将二者互换（遵循加法交换律），这是为了方便在后面的 `for` 循环中处理数位多的数在各数位相加时遇到数位小的数同一位为空的情况。之后声明变量 `t` 来存储当前数位的和，声明 `vector` 数组 `Z` 来存储倒序的计算结果。在后面的 `for` 循环中，对于 `X` 中的每一位，首先将数位和加上数位多的数 `X` 在那一位上的数字，接着判断，如果数位少的数 `Y` 在这一位上有数字，则把这个数字加到数位和中，若没有则忽略。此后，把当前数位和 `t` **经过取余**添加到数组 `Z` 的尾部，再让 `t` 自除以 10，这样来模拟进位。注意，这里的 `t` 不是在循环内部声明的，因为需要记录上一位的进位，所以初值设为 0，当当前数位需要向前进位，`t` 经过自除会保留需要进位的数值。在循环执行完毕之后，如果 `t` 还大于 0，说明是两个数字的最高位相加大于 10 而进了一位，需要特别判断，把所进位的数字填补到 `Z` 末尾。

**2.1.4 完整程序**

```cpp
#include<bits/stdc++.h>
using namespace std;

string a, b;
vector<int> A, B;

vector<int> add(vector<int> X, vector<int> Y) {
    if (X.size() < Y.size()) return add(Y, X);
    int t = 0;
    vector<int> Z;
    for (int i = 0; i < X.size(); i++) {
        t += X[i];
        if (i < Y.size()) t += Y[i];
        Z.push_back(t%10);
        t /= 10;
    }
    if (t) Z.push_back(t);
    return Z;
}

int main() {
    cin >> a >> b;
    for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');
    for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0');
    vector<int> C = add(A, B);
    for (int i = C.size() - 1; i >= 0; i--) cout << C[i];
    return 0;
}
```

测试数据

```
// 输入1
758697629755764233656583586095885515621263221
43911407555871606184651645365576032657600276444536

// 输出1
43912166253501361948885301949162128543115897707757
```

```
// 输入2
9693682019831948032205893649341864210056
5364262538969922163150565404570686390239

// 输出2
15057944558801870195356459053912550600295
```
