---
description: 了解贪心算法的基本理论，通过例题学习贪心算法的思想与实现代码，初步了解背包思想
---

# Lesson 27

## 一、贪心

### 1.1 贪心算法

在算法竞赛中求解某些问题时，只需要做出在当前看来是最好的选择，就可以获得最好的结果，而不需要去考虑整体上的最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择。选择的贪心策略必须具备**无后效性**，即**某个状态以前的过程不会影响以后的状态，只与当前状态有关**。

### 1.2 排队接水

你可以在[洛谷（P1223）](https://www.luogu.com.cn/problem/P1223)找到本题。

#### 题目描述

有 n 个人在一个水龙头前排队接水，假如每个人接水的时间为 $$T_i$$，请编程找出这 n 个人排队的一种顺序，使得 n 个人的平均等待时间最小。

#### 输入格式

第一行为一个整数 n。

第二行 n 个整数，第 i 个整数 $$T_i$$ 表示第 i 个人的等待时间 $$T_i$$。

#### 输出格式

输出文件有两行，第一行为一种平均时间最短的排队顺序；第二行为这种排列方案下的平均等待时间（输出结果精确到小数点后两位）。

#### 样例

**样例输入**

```
10 
56 12 1 99 1000 234 33 55 99 812
```

**样例输出**

```
3 2 7 8 1 4 9 6 10 5
291.90
```

#### 提示

$$n \leq 1000$$，$$t_i \leq 10^6$$，不保证 $$t_i$$ 不重复。

当 $$t_i$$ 重复时，按照输入顺序即可（sort 是可以的）

#### 分析

求最短平均时间就相当于求所有人的最短等待时间和。由于排队接水是一个人接着一个人的，也就是只允许最多一个人同时打水，所以，某一个人打水的时候，其身后的人的等待时间总和就是每个单人打水时间的和。假设经过安排后，第 i 个人的打水时间是 $$t_i$$。则所有人的打水时间总和 s 满足

$$
s = (n-1)t_1 + (n-2)t_2 + \dots + 1 \times t_{n-1} + 0 \times t_n
$$

由于 n 的值是固定的，所以 $$t_1$$ 的系数最大，$$t_n$$ 的系数最小。可以初步猜测，应该按照打水耗时从小到大排序，这样才能使 s 有最小值，则平均等待时间 $$\dfrac{s}{n}$$ 有最小值。

我们可以通过反例法证明贪心算法。假设最佳方案中，$$t_1$$ 到 $$t_1$$ 不是从小到大排列，即有 $$i \lt j$$ 时，$$t_i > t_j$$，那么这两项贡献的总时间是 $$s_1 = at_i + bt_j$$，其中系数 $$a \gt b$$。若将 $$t_i$$ 和 $$t_j$$ 调换，那么贡献总时间变为 $$s_2 = at_j + bt_i$$，两者相减

$$
s_1 - s_2 = at_i + bt_j - at_j - bt_i = a(t_i - t_j) + b(t_j - t_i) = (a - b)(t_i - t_j)
$$

因为 $$t_i \gt t_j$$ 且 $$a \gt b$$，所以 $$\Delta s \gt 0$$，即 $$s_1 \gt s_2$$，从而得出，调换顺序后，总等待时间会缩短，贪心算法成立。

#### 解答

```cpp
#include <bits/stdc++.h>
using namespace std;

long long n, sum; // sum若使用int类型会超出存储范围

struct water { // 结构体存储输入顺序和耗时
    int id, t;
} p[1005];

bool cmp (water a, water b) {
    if (a.t != b.t)
        return a.t < b.t; // 按时间从小到大
    return a.id < b.id; // 时间相同则按输入顺序
}

int main() {
    
    cin >> n;
    
    for (int i = 1; i <= n; i++) {
        cin >> p[i].t; // 输入耗时
        p[i].id = i; // 输入顺序
    }
    
    sort(p+1, p+n+1, cmp); // 排序
    
    for (int i = 1; i <= n; i++) {
        cout << p[i].id << " "; // 输出排序后的顺序
        sum += p[i].t * (n-i); // 根据公式算和
    }
    
    cout << endl;
    
    cout << fixed << setprecision(2) << sum * 1.0 / n;
    
	return 0;
}
```

### 1.3 独木舟

Jeffery 老师带着全班同学共 n 人去某地玩，需要租用一些独木舟渡过途中的河流，每只独木舟最多可乘坐两人，且每只独木舟的载重有限，为 w（单位为 kg），请求出，在不把同学扔下船的情况下，Jeffery 老师最少需要租多少只独木舟。

#### 输入格式

第一行依次为两个正整数，分别表示单只独木舟的最大载重 w 以及总人数 n；

第二行为 n 个整数，分别表示每个人的体重（单位为 kg）。

#### 输出格式

输出只有一行，为所需要独木舟的数量 k。

#### 分析

由于每只独木舟仅能容纳两人，那么不妨拿数据中质量最大与最小的人相比较，如果装得下两个人则两个人都乘坐一只独木舟，否则只载质量大的人，然后不断比较即可求出最少需要租的舟数。

#### 解答

```cpp
#include <bits/stdc++.h>
using namespace std;

int kg[105], n, li, boat;

int main() {
    
    cin >> li >> n;
    for (int i = 1; i <= n; i++) cin >> kg[i];
    
    sort(kg+1, kg+n+1); // 排序
    
    for (int i = n, j = 1; i >= j;) {
        if (kg[i] + kg[j] <= li) i--, j++, boat++; // 最大加上最小是否大于单只载重
        else i--, boat++; // 否则仅载最大的
    }
    
    cout << boat;
    
	return 0;
}
```

### 1.4 矿中取宝

Jeffery 家里有座矿，里面埋着不同种类的宝物。这座矿由于种种原因，每年只开放一次。每堆宝物有对应的价值 c（单位为万元）和质量 w（单位为 kg），且每种宝物都有无数堆，假设 Jeffrey 一次能够把矿里埋藏的总共 k 千克宝物拿出来，且宝物可以任意切割，问 Jeffrey 每年最多能用拿出的宝物换得多少万元额外收入？

#### 输入格式

第一行依次为两个正整数 k 和宝物的种类数量 n；

第二行至第 $$n+1$$ 行，每行依次为两个整数，分别代表该堆宝石的价值 c 和总质量 w。

#### 输出格式

输出只有一行，代表 Jeffrey 可以通过卖宝物赚取的额外收入，保留一位小数。

#### 分析

由于可以任意拿也可以任意切割，那就计算出性价比最高的宝物，然后全部拿这种宝物，就可以保证收入最大。

#### 解答

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, k;
double income;

struct node {
    int w, ic;
    double p;
} tr[105];

bool cmp(node a, node b) {
    return a.p > b.p; // 从大到小排序
}

int main() {

    cin >> k >> n;
    for (int i = 1; i <= n; i++) {
        cin >> tr[i].w >> tr[i].ic; // 分别输入质量和价值
        tr[i].p = tr[i].ic*1.0 / tr[i].w; // 计算性价比
    }
    
    sort(tr+1, tr+n+1, cmp); // 排序
    
    for (int i = 1; i <= n; i++) {
        if (k >= tr[i].w) income += tr[i].ic, k -= tr[i].w; // 若还装得下则装这堆宝物
        else {
            income += tr[i].p * k; // 否则切割
            break;
        } 
    }
    
    cout << fixed << setprecision(1) << income;
    
	return 0;
}
```

## 二、背包

### 2.1 矿中取钻石

在 Jeffery 某一次矿井勘探过程中，他突然发现了一条新的矿道，里面全部都是钻石矿！矿藏的每种不同钻石矿都有对应的价值 c（单位为万元）和质量 w（单位为克拉），每种钻石的总量是一定的。假设 Jeffrey 一次能够把矿里埋藏的总共 k 克拉钻石拿出来，且钻石不可以切割，问 Jeffrey 每年最多能用拿出的钻石换得多少万元额外收入？

#### 输入格式

第一行依次为两个正整数 k 和钻石的种类数量 n；

第二行至第 $$n+1$$ 行，每行依次为两个整数，分别代表该种钻石的总质量 $w$ 和价值 $c$。

#### 输出格式

输出只有一行，代表 Jeffrey 可以通过卖钻石赚取的额外收入，保留一位小数。

#### 分析

我们知道，贪心算法通常无法得出整体最优解。生活常识也告诉我们，在某个方面过于贪婪的行事方式，可能与最优的行事方式能造成的结果差之千里。这时候就需要适当取舍来保证最优解。对于此题来说，最优解取决于**不放当前宝物**以及**放当前宝物的代价（即减去代价之后的最优解）加上可得到的报酬**之间哪个值更大，而不能使用贪心算法。这里的分析步骤采用的是递推的思想。

假设 Jeffery 可以拿出 7 克拉钻石，且现在有三种钻石，分别为：

* 2 克拉，4 万元；
* 3 克拉，6 万元；
* 4 克拉，7 万元。

| 背包位         | 0 | 1 | 2 | 3 | 4 | 5  | 6  | 7  |
| ----------- | - | - | - | - | - | -- | -- | -- |
| 2 克拉 / 4 万元 | 0 | 0 | 4 | 4 | 4 | 4  | 4  | 4  |
| 3 克拉 / 6 万元 | 0 | 0 | 4 | 6 | 6 | 10 | 10 | 10 |
| 4 克拉 / 7 万元 | 0 | 0 | 4 | 6 | 7 | 10 | 11 | 13 |

所以最多可以收入 13 万元。

#### 解答

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, k, w[105], val[105], f[105][105];
//        质量    价值      背包位

int main() {
    
    cin >> k >> n;
    for (int i = 1; i <= n; i++) cin >> w[i] >> val[i];
    
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= k; j++) {
            // 如果当前背包位还装得下
            // 则求(不放当前宝物)以及(放的代价加上可得到的报酬)之间的最大值
            if (j >= w[i]) f[i][j] = max(f[i-1][j], f[i-1][j-w[i]] + val[i]);
            // 装不下则直接填入上一位的值
            else f[i][j] = f[i-1][j];
        }
    }
    
    // 输出背包最后一位的值
    cout << fixed << setprecision(1) << f[n][k];
    
	return 0;
}
```
